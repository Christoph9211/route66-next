# AGENT.md

This file provides guidance to Codex when working with code in this repository.
Build/Lint/Test Commands
    • Install Dependencies: Run npm install (Next.js 16 project using npm).
    • Development Server: Use npm run dev to start the Next.js dev server (default at <http://localhost:3000>).
    • Production Build: Use npm run build to compile the application for production, then npm run start to serve the built app.
    • Linting: Run npm run lint to lint the codebase with ESLint (using Next.js's core-web-vitals config).
    • Run All Tests:
    • npm test – Executes backend/utility tests using Node’s built-in test runner (looks for tests in the tests/ directory, e.g. tests/*.test.mjs).
    • npm run test_jest – Runs all Jest tests (for React components and frontend logic, typically in the __tests__/ directory).
    • Specific Test Suites:
    • npm run test:a11y – Runs only accessibility tests (Jest tests under __tests__/a11y/).
    • npm run test:vr – Runs Playwright end-to-end visual regression tests (in e2e/visual/). This will automatically launch the dev server and then run the tests (as configured in playwright.config.ts). Use npm run test:vr:update to update baseline screenshots for visual tests.
    • Run a Single Test: To run an individual test file, you can invoke the test runner directly. For example, use `npx jest __tests__/a11y/<TestFile>.tsx` for a specific Jest test, or `node --test tests/<file>.test.mjs` for a specific Node test. You can also pass a pattern to Jest (e.g. npm run test_jest -- -t "some test name").
Architecture and Code Structure
    • Next.js App Directory: This project uses Next.js 13+ App Router. The main application layout is defined in app/layout.tsx, which sets up global HTML structure (including <html lang="en">, <head> tags, and inserts components like <CanonicalUrl /> for the canonical link and <AgeGate /> for the age verification modal). The homepage content is in app/page.tsx, which is an async server component that fetches product data and renders the home page. Other pages (e.g. the Privacy Policy) reside in subdirectories under app/ (e.g. app/privacy-policy/page.tsx). The app uses Next’s metadata exports in pages/layout to define SEO meta tags (title, description, etc.), and uses export const revalidate = 3600 on pages to enable Incremental Static Regeneration (rebuilding pages every hour).
    • Component Structure: Reusable UI components are organized under the components/ directory. Notable components include:
    • AgeGate (components/AgeGate.tsx): A client-side modal that verifies the user’s age (21+) and handles cookie consent. It uses js-cookie to store a flag and only renders on first visit until the user confirms their age, then optionally shows a cookie consent prompt. It employs focus trapping (via focus-trap-react) and uses inert attributes to prevent background interaction when open.
    • AnalyticsConsentGate (components/AnalyticsConsentGate.tsx): A client component that conditionally loads Vercel Analytics and Speed Insights scripts. It listens for a consent status cookie (set by AgeGate or a cookie banner) and only injects analytics when consent is “accepted.” It also reacts to a custom consent:updated browser event so that analytics can toggle on if the user consents later.
    • Navigation & Accessibility: The header navigation is in components/Navigation.tsx (desktop and mobile menu logic), and there's a components/SkipLinks.tsx component providing “skip to content/navigation” links for keyboard users. A components/QuickNavigation.tsx floating widget appears after scrolling, offering quick scroll shortcuts (e.g. to Products section, Contact, or back to top) and a one-click call button. These enhance UX but are only visible as needed (e.g. QuickNavigation appears after scrolling down). The site is built with accessibility in mind: skip links, focus management, and ARIA attributes are used throughout. For example, SearchNavigation (components/SearchNavigation.tsx) implements an in-page product search with keyboard support and ARIA live announcements, allowing users to quickly find products and auto-scroll to them.
    • Page Sections: The homepage is composed of multiple section components: HeroSection, AboutSection, ContactSection, etc., as well as a ProductSection for listing products by category. The HomePage component (components/HomePage.tsx) ties these together. It receives a list of products (from the page) and groups them by category via a utility (see Data & Utilities below). Each category is rendered with a ProductSection containing product cards and possibly “Add to Cart” buttons.
    • Footer and SEO: components/FooterNavigation.tsx defines the footer content/links. The StructuredData component (components/StructuredData.tsx) is a server component that injects JSON-LD structured data into the page <head> for SEO (describing the business, its location, reviews, etc.). It obtains a nonce from request headers (set by a middleware, see Security below) to safely include inline <script type="application/ld+json"> tags under a strict CSP. The CanonicalUrl component ensures each page has a proper canonical link tag (using Next’s usePathname() to get the current route).
    • State and Data Management:
    • Static Data (Products): Product information is stored in a JSON file under public/products/products.json. A server-side utility getProducts() in lib/products.server.ts reads and parses this JSON at build/runtime, with validation to ensure data integrity (e.g. required fields, non-negative prices). The homepage uses getProducts() to retrieve all products, then passes them into the client component. In lib/products.ts, a helper function groupProductsByCategory(products) organizes products into categories (and sorts them, e.g. ensuring items marked “New” appear first and “Out of Stock” items last, then by name). This grouped structure is used to render product sections per category on the homepage. The project defines a TypeScript interface Product in types/product.ts for product objects (fields like name, category, price list, THC% etc.).
    • Global Cart Context: The application includes a client-side shopping cart system for e-commerce functionality. The logic resides in hooks/useCart.tsx, which defines a React context (CartProvider) to hold cart state in localStorage. The cart state includes items (each with product info, variant ID, quantity, price) and derived totals. The context provides methods to add, update, or remove items, and to toggle the cart’s visibility. It also listens for custom DOM events (cart:add, cart:update, cart:remove, cart:clear) so that any part of the UI can modify the cart by dispatching events (decoupling the actual button elements from direct context calls). For instance, an “Add to Cart” button in a product listing can simply have class add-to-cart and data attributes; a global click listener (utils/cartEvents.tsx) catches clicks on such elements and dispatches a cart:add event with the product details, which the Cart context handles to update state.
    • Cart UI: There are two main cart display components: CartDrawer and CartPage (both in the components/ folder).
        ◦ CartDrawer is a slide-out sidebar panel that appears when an item is added or when the user opens the cart. It shows a list of items with their quantities and subtotals, and allows adjusting quantities or removing items (these actions dispatch the corresponding cart events, which update context state). The drawer includes a “View Cart” button.
        ◦ CartPage is a full-page modal overlay for the cart (triggered by “View Cart”). It displays the cart items in a larger centered panel with a checkout button. It uses the context’s isPageOpen state to render only when needed, and provides an accessible dialog (role="dialog") for reviewing the cart. This separation allows a quick view (drawer) versus a detailed view (page overlay). Both components use the context’s useCart() hook to get state and actions. The cart system is entirely client-side (no backend integration for checkout in this codebase yet), storing data in localStorage and intended to be extended for actual payment processing or API calls in the future.
    • Utilities and Hooks: Various utility functions and custom hooks encapsulate common logic:
    • Keyboard Navigation Hook: hooks/useNavigation.ts is likely used to enhance keyboard interactions across the site (for example, handling arrow keys in menus or trapping focus in modals). The repository also includes a docs/KEYBOARD_ACCESSIBILITY_GUIDE.md to document how keyboard and focus interactions are implemented, indicating a strong emphasis on accessibility.
    • Scroll and Slug Utilities: utils/scrollToSection.ts provides smooth scrolling to page anchors/sections by ID, used by navigation links (e.g., clicking a nav item scrolls to the corresponding section rather than loading a new page, since the site is mostly a single-page layout). utils/slugify.ts creates URL-friendly IDs from strings (used to generate element IDs for product categories and product items, so that the search and navigation can target them).
    • Auto Contrast Utility: utils/autoContrast.tsx contains functions to automatically adjust text color for readability based on background color (computing luminance and contrast ratio). The homepage uses applyAutoContrast() on certain elements with the CSS class .auto-contrast (for instance, headings that overlay variable background colors) to ensure text is either white or black for sufficient contrast. This function is invoked in a useEffect on the client after rendering product sections.
    • SEO and Security:
    • Meta & SEO: The site’s metadata (such as title, description, keywords) is centrally defined in app/layout.tsx (for global defaults) and in individual page files for page-specific titles (e.g. the Privacy Policy page sets its own title). It also includes Open Graph metadata for social sharing. The StructuredData component (described earlier) provides SEO-rich snippets (business details, reviews, etc.), which improve search visibility for the local business.
    • Content Security Policy (CSP): A custom Next.js middleware is implemented to strengthen security. The file proxy.ts (acting as a middleware) generates a random nonce and sets a Content-Security-Policy header on all responses. This CSP allows scripts only from self and Vercel’s analytics domains and includes the generated 'nonce-<value>' so that the inline JSON-LD scripts inserted by StructuredData can run. The nonce is also added as a custom header (x-csp-nonce) on the request to be accessible server-side. The StructuredData component reads this header via Next’s headers() function to retrieve the nonce and attach it to its <script> tags. This coordination across middleware and component ensures inline scripts pass CSP. The middleware (via export const config.matcher = '/:path*') applies to all routes, and also sets other security headers (like X-Content-Type-Options, Permissions-Policy, etc.) as defined in next.config.ts. In next.config.ts, you’ll also find static asset caching headers are configured for performance (long cache lifetime for fonts/images and immutable _next/static files, while HTML pages use must-revalidate to allow the browser back/forward cache).
    • Testing Strategy: The repository has a comprehensive test suite covering different aspects of the application:
    • Node.js Tests (Integration/Config): Under the tests/ directory are tests written with Node’s built-in test runner (ESM modules). These tests (*.test.mjs) verify things like package.json scripts and dependencies, TypeScript config (ensuring strict mode and path aliases are set), presence of important files, and static content. For example, tests/config.test.mjs checks that required NPM scripts exist and that TypeScript config meets expectations, and tests/seo.test.mjs checks that the layout defines metadata and includes critical components like <AgeGate /> and <CanonicalUrl />. These run via npm test.
    • Jest Tests (Unit/Component): The __tests__/ directory contains Jest tests, primarily focused on frontend components and accessibility. Notably, in __tests__/a11y/, tests use jest-axe and React Testing Library to ensure components have no accessibility violations. For example, there’s a test for the GoogleBusinessIntegration component that renders it and asserts axe() finds no issues. Jest is also configured (see jest.config.mjs) to use jsdom for a DOM environment and to recognize the @/ path alias. Run these with npm run test_jest (or the specific test:a11y script for just the accessibility subset).
    • Playwright E2E Tests: The e2e/ folder contains end-to-end tests using Playwright. Currently these focus on visual regression: for instance, e2e/visual/home.spec.ts loads the home page and uses expect(page).toHaveScreenshot(...) to compare against baseline screenshots. There is configuration to automatically start the dev server when running Playwright tests (see the webServer section in playwright.config.ts). These tests ensure that critical pages render correctly and consistently. Use npm run test:vr to execute them. Updating snapshots (if the design changes intentionally) is done via npm run test:vr:update.
Additional Notes
    • TypeScript and Path Aliases: The project is written in TypeScript and uses strict mode. It defines a convenient path alias @/ to refer to the project root (configured in tsconfig.json). This means imports like import X from '@/components/...' will resolve correctly. When adding new files, you can import them using the @/ alias instead of relative paths.
    • Styling: Styling is primarily done via Tailwind CSS utility classes (Tailwind is included via the PostCSS plugin configured in postcss.config.mjs). You’ll see lots of Tailwind classes in JSX (e.g. className="bg-gray-50 dark:bg-gray-900 ..."). The project also self-hosts Font Awesome icons: CSS for Font Awesome is imported from app/styles/fa/*.css and font files are placed in public/webfonts/. When modifying styles, ensure not to remove or break these global styles (they are imported in the layout).
    • Environment and Deployment: The presence of a vercel.json suggests the app is intended to be deployed on Vercel. The code avoids use of any server-side secrets or API keys (it’s a mostly static site). If adding features that require secrets or runtime configuration, coordinate with environment variables and the Vercel platform conventions.
Keep these structural and architectural points in mind when working with the repository. Focus on maintaining the accessibility and performance practices already in place (e.g. follow the established patterns for modals, focus management, and consent gating), and ensure any new code integrates with the testing setup (add corresponding tests under the right directory). This will help keep the project consistent and reliable.
